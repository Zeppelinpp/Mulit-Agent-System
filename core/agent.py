import json
import asyncio
from abc import ABC, abstractmethod
from pydantic import BaseModel, ValidationError, Field, PrivateAttr
from typing import List, Optional, Any, Dict, Literal, Callable
from openai import OpenAI, AsyncOpenAI
from .agent_prompts import SYSTEM_PROMPT, REVIEW_PROMPT
from .utils import ToolConverter
from rich.console import Console
from rich.table import Table


class Task(BaseModel):
    """Definition of a task."""

    id: str
    task_name: str
    goal: str
    result: str
    status: Literal["pending", "in_progress", "success", "failure"] = "pending"
    agent_name: str = Field(
        ..., description="The name of the agent that is assigned to the task"
    )
    context: Dict[str, Any] = Field(..., description="The context of the task")
    _done_event: asyncio.Event = PrivateAttr(default_factory=asyncio.Event)


class TaskList(BaseModel):
    """List of tasks generated by Planning"""

    sequential_tasks: List[Task]
    parallel_tasks: List[Task]

    def pretty_print(self):
        console = Console()
        console.print("\n[bold green]Sequential Tasks:[/bold green]")
        if self.sequential_tasks:
            table = Table(show_header=True, header_style="bold magenta")
            table.add_column("ID", style="dim")
            table.add_column("Name")
            table.add_column("Goal") 
            table.add_column("Assigned Agent", style="bold")
            for task in self.sequential_tasks:
                table.add_row(task.id, task.task_name, task.goal, task.agent_name)
            console.print(table)
        else:
            console.print("  [italic]None[/italic]")

        console.print("\n[bold blue]Parallel Tasks:[/bold blue]")
        if self.parallel_tasks:
            table = Table(show_header=True, header_style="bold cyan")
            table.add_column("ID", style="dim")
            table.add_column("Name")
            table.add_column("Goal")
            table.add_column("Assigned Agent", style="bold")
            for task in self.parallel_tasks:
                table.add_row(task.id, task.task_name, task.goal, task.agent_name)
            console.print(table)
        else:
            console.print("  [italic]None[/italic]")

class AgentState(BaseModel):
    """State of the Agent."""

    assigned_tasks: List[Task] = []
    success_tasks: List[Task] = []
    failed_tasks: List[Task] = []
    retries: int = 0


class ReviewResult(BaseModel):
    """Result of the review."""

    is_success: Literal["success", "failure"]
    feedback: Optional[str]


class BaseAgent(ABC):
    @property
    @abstractmethod
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        pass

    @state.setter
    @abstractmethod
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        pass

    @abstractmethod
    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]) -> Any:
        """Execute a tool with given arguments.

        Args:
            tool_name: Name of the tool to execute
            tool_args: Arguments to pass to the tool

        Returns:
            Result of tool execution
        """
        pass

    @abstractmethod
    async def _get_context(self) -> Dict[str, Any]:
        """Get the current context of the agent.

        Returns:
            Dictionary containing agent's context
        """
        pass


class PlanningAgent(BaseAgent):
    def __init__(
        self,
        name: str,
        system_prompt: Optional[str] = None,
        workers: List[Dict[str, Any]] = [],
        model: Optional[str] = None,
        client: Optional[OpenAI | AsyncOpenAI] = None,
    ):
        self.name = name
        self.system_prompt = (
            SYSTEM_PROMPT.format(schema=TaskList.model_json_schema(), workers=workers)
            if system_prompt is None
            else system_prompt
        )
        self.client = (
            AsyncOpenAI(
                api_key="sk-4cd77baf9cdb43aeadb180887e28ad22",
                base_url="https://api.deepseek.com",
            )
            if client is None
            else client
        )
        self.model = "deepseek-chat" if model is None else model
        self._state = AgentState(retries=0)

    @property
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        return self._state.model_dump()

    @state.setter
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        if isinstance(value, dict):
            self._state = AgentState(**value)
        else:
            self._state = value

    @property
    def name(self) -> str:
        return self._name

    @property
    def system_prompt(self) -> str:
        return self._system_prompt

    @name.setter
    def name(self, value: str):
        self._name = value

    @system_prompt.setter
    def system_prompt(self, value: str):
        self._system_prompt = value

    async def _get_context(self) -> Dict[str, Any]:
        # TODO: get context from the agent's memory
        return {}

    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]) -> Any:
        # TODO: execute the tool with given arguments
        pass

    async def plan(self, query: str) -> TaskList:
        user_message = {"role": "user", "content": query}
        context = await self._get_context()
        # planning and create task list
        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": self.system_prompt + f"\nContext: {context}",
                },
                user_message,
            ],
            response_format={"type": "json_object"},
        )
        try:
            task_list = TaskList.model_validate_json(
                response.choices[0].message.content
            )
            return task_list
        except ValidationError as e:
            if self._state.retries < 3:
                self._state.retries += 1
                return await self.plan(query)
            else:
                raise e

    async def _review_single_task(self, task: Task) -> ReviewResult:
        goal = task.goal
        result = task.result
        review = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": REVIEW_PROMPT.format(
                        schema=ReviewResult.model_json_schema()
                    ),
                },
                {"role": "user", "content": f"Goal: {goal}\nResult: {result}"},
            ],
            response_format={"type": "json_object"},
        )
        try:
            review_result = ReviewResult.model_validate_json(
                review.choices[0].message.content
            )
            return review_result
        except ValidationError as e:
            if self._state.retries < 3:
                self._state.retries += 1
                return await self._review_single_task(task)
            else:
                raise e


class AgentWorker(BaseAgent):
    def __init__(
        self,
        name: str,
        description: str,
        model: str,
        client: OpenAI | AsyncOpenAI,
        system_prompt: str,
        tools: List[Callable],
    ):
        self._name = name
        self._description = description
        self.model = model
        self.client = client
        self.system_prompt = system_prompt
        self.tools = tools
        self.tools_registry = {tool.__name__: tool for tool in self.tools}
        self.task_queue = asyncio.Queue()
        self._state = AgentState()

    @property
    def name(self) -> str:
        return self._name

    @property
    def description(self) -> Dict[str, Any]:
        return {
            "name": self._name,
            "description": self._description,
        }

    @property
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        return self._state.model_dump()

    @state.setter
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        if isinstance(value, dict):
            self._state = AgentState(**value)
        else:
            self._state = value

    def _setup_tools(self) -> List[Dict[str, Any]]:
        """Convert callable tools to OpenAI tool format."""

        tool_list = []
        for tool in self.tools:
            tool_schema = ToolConverter.convert_callable_to_tool(tool)
            tool_list.append(tool_schema)

        return tool_list

    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]):
        tool = self.tools_registry[tool_name]
        if asyncio.iscoroutinefunction(tool):
            result = await tool(**tool_args)
        else:
            result = tool(**tool_args)
        return result

    async def _handle_tool_calls(self, tool_calls: List[Dict[str, Any]]):
        tool_results = []
        for tool_call in tool_calls:
            tool_name = tool_call.function.name
            tool_args = json.loads(tool_call.function.arguments)
            result = await self._execute_tool(tool_name, tool_args)
            tool_result = {
                "tool_call_id": tool_call.id,
                "tool_name": tool_name,
                "tool_result": result,
            }
            tool_results.append(tool_result)
        return tool_results

    async def _get_context(self) -> Dict[str, Any]:
        # TODO: get context from the agent's memory
        return {}

    async def _execute_task(self, task: Task):
        task.status = "in_progress"
        task_context = task.context
        print(
            f"Agent: {self.name} running task: {task.task_name}\nGoal: {task.goal}\n==============\n"
        )
        user_message = [
            {
                "role": "user",
                "content": f"Task: {task.task_name}\nGoal: {task.goal}\nContext: {task_context}",
            }
        ]
        while True:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                ]
                + user_message,
                tools=self._setup_tools(),
            )

            message = response.choices[0].message
            tool_calls = message.tool_calls

            if not tool_calls:
                task.result = message.content
                task.status = "success"
                print(f"Task {task.task_name} completed with result:\n{task.result}\n")
                return task

            tool_results = await self._handle_tool_calls(tool_calls)

            # Add tool results to conversation
            user_message.append(
                {"role": "assistant", "content": None, "tool_calls": tool_calls}
            )
            for tool_result in tool_results:
                user_message.append(
                    {
                        "role": "tool",
                        "content": json.dumps(tool_result["tool_result"]),
                        "tool_call_id": tool_result["tool_call_id"],
                    }
                )

    async def run(self, result_queue: asyncio.Queue):
        while True:
            try:
                task = await self.task_queue.get()
                if task is None:
                    self.task_queue.task_done()
                    break

                self._state.assigned_tasks.append(task)
                result = await self._execute_task(task)
                print(f"{self.name} putting result in queue\n")
                await result_queue.put(result)
                self.task_queue.task_done()
            except Exception as e:
                print(f"Error in worker {self.name}: {e}")
                self.task_queue.task_done()
                continue


class AgentRunner:
    def __init__(self, planner: PlanningAgent, workers: Dict[str, AgentWorker]):
        self.planner = planner
        self.workers = workers
        self.result_queue = asyncio.Queue()
        self.running = True

    async def dispatch_task(self, task: Task):
        assigned_agent = task.agent_name
        if not assigned_agent in self.workers:
            raise ValueError(f"Agent {assigned_agent} not found")
        await self.workers[assigned_agent].task_queue.put(task)

    async def execute_parallel(self, tasks: List[Task]):
        for task in tasks:
            await self.dispatch_task(task)

    async def execute_sequential(self, tasks: List[Task]):
        for task in tasks:
            await self.dispatch_task(task)
            await task._done_event.wait()

    async def handle_result_loop(self):
        while True:
            task = await self.result_queue.get()
            if task is None:
                self.result_queue.task_done()
                break
            try:
                print(f"Reviewing task: {task.task_name}")
                review = await self.planner._review_single_task(task)
                print(f"Review result: {review.feedback}")
                if review.is_success == "success":
                    self.planner._state.success_tasks.append(task)
                    print(f"Task {task.task_name} passed")
                else:
                    task.status = "failure"
                    self.planner._state.failed_tasks.append(task)
                    print(f"Task {task.task_name} failed")

                task._done_event.set()
                self.result_queue.task_done()
            except Exception as e:
                print(f"Error in review loop: {e}")
                if not self.running:
                    break

    async def run(self, query: str):
        task_list = await self.planner.plan(query)
        task_list.pretty_print()

        # Start worker tasks
        worker_tasks = []
        for worker in self.workers.values():
            worker_task = asyncio.create_task(worker.run(self.result_queue))
            worker_tasks.append(worker_task)

        # Start review handler
        review_handler = asyncio.create_task(self.handle_result_loop())

        # Execute tasks
        if task_list.parallel_tasks:
            await self.execute_parallel(task_list.parallel_tasks)

        if task_list.sequential_tasks:
            await self.execute_sequential(task_list.sequential_tasks)

        # Wait for all results to be processed
        await self.result_queue.join()

        await self.result_queue.put(None)

        # Signal workers to stop
        for worker in self.workers.values():
            await worker.task_queue.put(None)

        # Wait for all workers to finish
        await asyncio.gather(*worker_tasks, return_exceptions=True)

        # Stop review handler
        self.running = False
        await review_handler

        return self.planner._state
