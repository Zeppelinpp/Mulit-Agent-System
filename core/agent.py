from email import message
import json
import asyncio
from abc import ABC, abstractmethod
from pydantic import BaseModel, ValidationError, Field, PrivateAttr
from typing import List, Optional, Any, Dict, Literal, Callable
from openai import OpenAI, AsyncOpenAI
from .agent_prompts import SYSTEM_PROMPT, REVIEW_PROMPT
from .utils import ToolConverter
from rich.console import Console
from rich.table import Table
from rich.live import Live
from rich.panel import Panel
from rich.layout import Layout
from rich.text import Text
from rich.spinner import Spinner
from rich.markdown import Markdown
import threading
import time


class Task(BaseModel):
    """Definition of a task."""

    id: str
    task_name: str
    goal: str
    result: str
    status: Literal["pending", "in_progress", "success", "failure"] = "pending"
    agent_name: str = Field(
        ..., description="The name of the agent that is assigned to the task"
    )
    context: Dict[str, Any] = Field(..., description="The context of the task")
    _done_event: asyncio.Event = PrivateAttr(default_factory=asyncio.Event)

    def overview(self):
        return f"Task:{self.task_name}\nGoal:{self.goal}\nResult:{self.result}"

class TaskList(BaseModel):
    """List of tasks generated by Planning"""

    sequential_tasks: List[Task]
    parallel_tasks: List[Task]

    def pretty_print(self):
        console = Console()
        
        # Create a more elegant task overview
        console.print(f"\n[bold blue]📋 Task Planning Complete[/bold blue]")
        
        if self.sequential_tasks:
            console.print(f"\n[bold green]🔄 Sequential Tasks ({len(self.sequential_tasks)} tasks)[/bold green]")
            table = Table(show_header=True, header_style="bold magenta", border_style="green", padding=(0, 1), show_lines=True)
            table.add_column("Step", style="bold cyan", width=6, justify="center")
            table.add_column("Task Name", style="bold white", width=25)
            table.add_column("Goal", style="dim white", width=50)
            table.add_column("Agent", style="bold yellow", width=15)
            
            for i, task in enumerate(self.sequential_tasks, 1):
                table.add_row(
                    f"{i}",
                    task.task_name,
                    task.goal,
                    task.agent_name
                )
            console.print(table)
        else:
            console.print(f"\n[bold dim]🔄 Sequential Tasks: None[/bold dim]")

        if self.parallel_tasks:
            console.print(f"\n[bold blue]⚡ Parallel Tasks ({len(self.parallel_tasks)} tasks)[/bold blue]")
            table = Table(show_header=True, header_style="bold cyan", border_style="blue", padding=(0, 1), show_lines=True)
            table.add_column("ID", style="bold cyan", width=6, justify="center")
            table.add_column("Task Name", style="bold white", width=25)
            table.add_column("Goal", style="dim white", width=50)
            table.add_column("Agent", style="bold yellow", width=15)
            
            for task in self.parallel_tasks:
                table.add_row(
                    task.id,
                    task.task_name,
                    task.goal,
                    task.agent_name
                )
            console.print(table)
        else:
            console.print(f"\n[bold dim]⚡ Parallel Tasks: None[/bold dim]")
            
        # Add execution summary
        total_tasks = len(self.sequential_tasks) + len(self.parallel_tasks)
        console.print(f"\n[bold]📊 Total Tasks: {total_tasks}[/bold] ([green]{len(self.sequential_tasks)} sequential[/green], [blue]{len(self.parallel_tasks)} parallel[/blue])")
        console.print("[dim]Starting task execution...[/dim]\n")

class AgentState(BaseModel):
    """State of the Agent."""

    assigned_tasks: List[Task] = []
    success_tasks: List[Task] = []
    failed_tasks: List[Task] = []
    retries: int = 0


class ReviewResult(BaseModel):
    """Result of the review."""

    is_success: Literal["success", "failure"]
    feedback: Optional[str]


class BaseAgent(ABC):
    @property
    @abstractmethod
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        pass

    @state.setter
    @abstractmethod
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        pass

    @abstractmethod
    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]) -> Any:
        """Execute a tool with given arguments.

        Args:
            tool_name: Name of the tool to execute
            tool_args: Arguments to pass to the tool

        Returns:
            Result of tool execution
        """
        pass

    @abstractmethod
    async def _get_context(self) -> Dict[str, Any]:
        """Get the current context of the agent.

        Returns:
            Dictionary containing agent's context
        """
        pass


class PlanningAgent(BaseAgent):
    def __init__(
        self,
        name: str,
        system_prompt: Optional[str] = None,
        workers: List[Dict[str, Any]] = [],
        model: Optional[str] = None,
        client: Optional[OpenAI | AsyncOpenAI] = None,
    ):
        self.name = name
        self.system_prompt = (
            SYSTEM_PROMPT.format(schema=TaskList.model_json_schema(), workers=workers)
            if system_prompt is None
            else system_prompt
        )
        self.client = (
            AsyncOpenAI(
                api_key="sk-4cd77baf9cdb43aeadb180887e28ad22",
                base_url="https://api.deepseek.com",
            )
            if client is None
            else client
        )
        self.model = "deepseek-chat" if model is None else model
        self._state = AgentState(retries=0)

    @property
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        return self._state.model_dump()

    @state.setter
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        if isinstance(value, dict):
            self._state = AgentState(**value)
        else:
            self._state = value

    @property
    def name(self) -> str:
        return self._name

    @property
    def system_prompt(self) -> str:
        return self._system_prompt

    @name.setter
    def name(self, value: str):
        self._name = value

    @system_prompt.setter
    def system_prompt(self, value: str):
        self._system_prompt = value

    async def _get_context(self) -> Dict[str, Any]:
        # TODO: get context from the agent's memory
        return {}

    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]) -> Any:
        # TODO: execute the tool with given arguments
        pass

    async def plan(self, query: str) -> TaskList:
        user_message = {"role": "user", "content": query}
        context = await self._get_context()
        
        # Show planning status
        status_manager.update_agent_status(
            "Planner", 
            "working", 
            "Task Planning", 
            "analyzing query and creating tasks"
        )
        
        # planning and create task list
        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": self.system_prompt + f"\nContext: {context}",
                },
                user_message,
            ],
            response_format={"type": "json_object"},
        )
        task_list_json = response.choices[0].message.content
        try:
            task_list = TaskList.model_validate_json(task_list_json)
            
            status_manager.update_agent_status(
                "Planner", 
                "completed", 
                "Task Planning", 
                f"created {len(task_list.sequential_tasks + task_list.parallel_tasks)} tasks"
            )
            
            return task_list
        except ValidationError as e:
            if self._state.retries < 3:
                self._state.retries += 1
                status_manager.update_agent_status(
                    "Planner", 
                    "working", 
                    "Task Planning", 
                    f"retrying planning (attempt {self._state.retries})"
                )
                return await self.plan(query)
            else:
                status_manager.update_agent_status(
                    "Planner", 
                    "failed", 
                    "Task Planning", 
                    "planning failed after retries"
                )
                raise e

    async def _review_single_task(self, task: Task) -> ReviewResult:
        goal = task.goal
        result = task.result
        review = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": REVIEW_PROMPT.format(
                        schema=ReviewResult.model_json_schema()
                    ),
                },
                {"role": "user", "content": f"Goal: {goal}\nResult: {result}"},
            ],
            response_format={"type": "json_object"},
        )
        review_result_json = review.choices[0].message.content
        try:
            review_result = ReviewResult.model_validate_json(review_result_json)
            return review_result
        except ValidationError as e:
            if self._state.retries < 3:
                self._state.retries += 1
                return await self._review_single_task(task)
            else:
                raise e
    
    async def report(self, task_list: TaskList, query: str):
        """Generate and display a comprehensive final report with rich formatting."""
        console = Console()
        
        # Collect all tasks and categorize them
        all_tasks = task_list.sequential_tasks + task_list.parallel_tasks
        success_tasks = [task for task in all_tasks if task.status == "success"]
        failed_tasks = [task for task in all_tasks if task.status == "failure"]
        
        # Header
        console.print(f"\n[bold blue]📊 Final Execution Report[/bold blue]")
        console.print(f"[dim]Query: {query}[/dim]\n")
        
        # Summary Statistics
        total_tasks = len(all_tasks)
        success_count = len(success_tasks)
        failure_count = len(failed_tasks)
        success_rate = (success_count / total_tasks * 100) if total_tasks > 0 else 0
        
        stats_table = Table(show_header=False, border_style="green", padding=(0, 2))
        stats_table.add_column("Metric", style="bold cyan")
        stats_table.add_column("Value", style="bold white")
        
        stats_table.add_row("Total Tasks", str(total_tasks))
        stats_table.add_row("✓ Successful", f"[green]{success_count}[/green]")
        stats_table.add_row("✗ Failed", f"[red]{failure_count}[/red]")
        stats_table.add_row("Success Rate", f"[{'green' if success_rate >= 80 else 'yellow' if success_rate >= 50 else 'red'}]{success_rate:.1f}%[/{'green' if success_rate >= 80 else 'yellow' if success_rate >= 50 else 'red'}]")
        
        console.print(Panel(stats_table, title="[bold green]📈 Execution Summary[/bold green]", border_style="green"))
        
        # Successful Tasks Details
        if success_tasks:
            console.print(f"\n[bold green]✅ Successful Tasks ({len(success_tasks)})[/bold green]")
            success_table = Table(show_header=True, header_style="bold magenta", border_style="green", padding=(0, 1), show_lines=True)
            success_table.add_column("Task", style="bold white", width=25)
            success_table.add_column("Goal", style="dim white", width=40)
            success_table.add_column("Result", style="green", width=50)
            success_table.add_column("Agent", style="bold yellow", width=15)
            
            for task in success_tasks:
                # Truncate long results for display
                result_display = task.result[:100] + "..." if len(task.result) > 100 else task.result
                success_table.add_row(
                    task.task_name,
                    task.goal,
                    result_display,
                    task.agent_name
                )
            console.print(success_table)
        
        # Failed Tasks Details
        if failed_tasks:
            console.print(f"\n[bold red]❌ Failed Tasks ({len(failed_tasks)})[/bold red]")
            failed_table = Table(show_header=True, header_style="bold magenta", border_style="red", padding=(0, 1), show_lines=True)
            failed_table.add_column("Task", style="bold white", width=25)
            failed_table.add_column("Goal", style="dim white", width=40)
            failed_table.add_column("Error/Result", style="red", width=50)
            failed_table.add_column("Agent", style="bold yellow", width=15)
            
            for task in failed_tasks:
                # Truncate long results for display
                result_display = task.result[:100] + "..." if len(task.result) > 100 else task.result
                failed_table.add_row(
                    task.task_name,
                    task.goal,
                    result_display,
                    task.agent_name
                )
            console.print(failed_table)
        
        # Agent Performance Summary
        agent_stats = {}
        for task in all_tasks:
            agent_name = task.agent_name
            if agent_name not in agent_stats:
                agent_stats[agent_name] = {"total": 0, "success": 0, "failed": 0}
            
            agent_stats[agent_name]["total"] += 1
            if task.status == "success":
                agent_stats[agent_name]["success"] += 1
            elif task.status == "failure":
                agent_stats[agent_name]["failed"] += 1
        
        if agent_stats:
            console.print(f"\n[bold blue]🤖 Agent Performance[/bold blue]")
            agent_table = Table(show_header=True, header_style="bold magenta", border_style="blue", padding=(0, 1))
            agent_table.add_column("Agent", style="bold cyan", width=20)
            agent_table.add_column("Total Tasks", style="white", width=12, justify="center")
            agent_table.add_column("Success", style="green", width=10, justify="center")
            agent_table.add_column("Failed", style="red", width=10, justify="center")
            agent_table.add_column("Success Rate", style="yellow", width=15, justify="center")
            
            for agent_name, stats in agent_stats.items():
                rate = (stats["success"] / stats["total"] * 100) if stats["total"] > 0 else 0
                rate_color = "green" if rate >= 80 else "yellow" if rate >= 50 else "red"
                agent_table.add_row(
                    agent_name,
                    str(stats["total"]),
                    str(stats["success"]),
                    str(stats["failed"]),
                    f"[{rate_color}]{rate:.1f}%[/{rate_color}]"
                )
            console.print(agent_table)
        
                # Generate AI summary if there are results
        if all_tasks:
            console.print(f"\n[bold magenta]🤖 AI Summary[/bold magenta]")
            
            overall_result = []
            for task in all_tasks:
                overall_result.append(task.overview())
            overall_result_str = "\n".join(overall_result)
            
            # Generate AI summary with markdown formatting
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system", 
                        "content": f"You are providing a final summary for the user's query: '{query}'\n"
                                 f"Analyze the following task results and provide a concise, helpful summary of what was accomplished, "
                                 f"any issues encountered, and overall assessment. Be specific about the outcomes.\n"
                                 f"Format your response in markdown with appropriate headers, bullet points, and emphasis for better readability.\n\n"
                                 f"Task Results:\n{overall_result_str}"
                    }
                ],
                stream=True,
            )
            
            # Collect the full AI summary
            summary_text = ""
            async for chunk in response:
                if chunk.choices[0].delta.content:
                    content = chunk.choices[0].delta.content
                    summary_text += content
            
            # Render the markdown summary with Rich
            if summary_text.strip():
                markdown_summary = Markdown(summary_text)
                console.print(Panel(markdown_summary, title="[bold magenta]📝 Executive Summary[/bold magenta]", border_style="magenta", padding=(1, 2)))
        
        # Final separator
        console.print(f"\n[bold blue]{'='*80}[/bold blue]")
        console.print(f"[dim]Report generated successfully ✨[/dim]\n")
        


class AgentStatus:
    """Manages the live status display for all agents"""

    def __init__(self):
        self.console = Console()
        self.agent_statuses = {}
        self.live = None
        self._lock = threading.Lock()

    def start_live_display(self):
        """Start the live display"""
        self.live = Live(self._generate_display(), console=self.console, refresh_per_second=4)
        self.live.start()

    def stop_live_display(self):
        """Stop the live display"""
        if self.live:
            self.live.stop()

    def update_agent_status(self, agent_name: str, status: str, task_name: str = "", details: str = ""):
        """Update the status of an agent"""
        with self._lock:
            self.agent_statuses[agent_name] = {
                "status": status,
                "task_name": task_name,
                "details": details,
                "timestamp": time.time()
            }
            if self.live:
                self.live.update(self._generate_display())

    def remove_agent_status(self, agent_name: str):
        """Remove an agent from the status display"""
        with self._lock:
            if agent_name in self.agent_statuses:
                del self.agent_statuses[agent_name]
                if self.live:
                    self.live.update(self._generate_display())

    def _generate_display(self):
        """Generate the live display content"""
        if not self.agent_statuses:
            return Panel("[dim]All agents idle[/dim]", title="[bold blue]Agent Status[/bold blue]", border_style="blue")
            
        table = Table(show_header=True, header_style="bold magenta", border_style="dim", show_lines=True)
        table.add_column("Agent", style="cyan")
        table.add_column("Status", style="yellow")
        table.add_column("Current Task", style="green")
        table.add_column("Details", style="dim")
        
        for agent_name, info in self.agent_statuses.items():
            status_text = info["status"]
            if info["status"] == "working":
                status_text = f"[bold yellow]● {info['status']}[/bold yellow]"
            elif info["status"] == "completed":
                status_text = f"[bold green]✓ {info['status']}[/bold green]"
            elif info["status"] == "failed":
                status_text = f"[bold red]✗ {info['status']}[/bold red]"
            else:
                status_text = f"[dim]{info['status']}[/dim]"
                
            table.add_row(
                f"[bold]{agent_name}[/bold]",
                status_text,
                f"[dim]{info['task_name']}[/dim]" if info['task_name'] else "[dim]idle[/dim]",
                f"[dim]{info['details']}[/dim]"
            )
            
        return Panel(table, title="[bold blue]Agent Worker Status[/bold blue]", border_style="blue")

# Global status manager
status_manager = AgentStatus()


class AgentWorker(BaseAgent):
    def __init__(
        self,
        name: str,
        description: str,
        model: str,
        client: OpenAI | AsyncOpenAI,
        system_prompt: str,
        tools: List[Callable],
    ):
        self._name = name
        self._description = description
        self.model = model
        self.client = client
        self.system_prompt = system_prompt
        self.tools = tools
        self.tools_registry = {tool.__name__: tool for tool in self.tools}
        self.task_queue = asyncio.Queue()
        self._state = AgentState()

    @property
    def name(self) -> str:
        return self._name

    @property
    def description(self) -> Dict[str, Any]:
        return {
            "name": self._name,
            "description": self._description,
        }

    @property
    def state(self) -> Dict[str, Any]:
        """Current state of the Agent."""
        return self._state.model_dump()

    @state.setter
    def state(self, value: Dict[str, Any]):
        """Set the current state of the Agent."""
        if isinstance(value, dict):
            self._state = AgentState(**value)
        else:
            self._state = value

    def _setup_tools(self) -> List[Dict[str, Any]]:
        """Convert callable tools to OpenAI tool format."""

        tool_list = []
        for tool in self.tools:
            tool_schema = ToolConverter.convert_callable_to_tool(tool)
            tool_list.append(tool_schema)

        return tool_list

    async def _execute_tool(self, tool_name: str, tool_args: Dict[str, Any]):
        status_manager.update_agent_status(
            self.name,
            "working",
            details=f"executing {tool_name}"
        )
        tool = self.tools_registry[tool_name]
        if asyncio.iscoroutinefunction(tool):
            result = await tool(**tool_args)
        else:
            result = tool(**tool_args)
        return result

    async def _handle_tool_calls(self, tool_calls: List[Dict[str, Any]]):
        tool_results = []
        for tool_call in tool_calls:
            tool_name = tool_call.function.name
            tool_args = json.loads(tool_call.function.arguments)
            result = await self._execute_tool(tool_name, tool_args)
            tool_result = {
                "tool_call_id": tool_call.id,
                "tool_name": tool_name,
                "tool_result": result,
            }
            tool_results.append(tool_result)
        return tool_results

    async def _get_context(self) -> Dict[str, Any]:
        # TODO: get context from the agent's memory
        return {}

    async def _execute_task(self, task: Task):
        task.status = "in_progress"
        task_context = task.context

        status_manager.update_agent_status(
            self.name,
            "working",
            task.task_name,
            "starting task"
        )

        user_message = [
            {
                "role": "user",
                "content": f"Task: {task.task_name}\nGoal: {task.goal}\nContext: {task_context}",
            }
        ]
        while True:
            status_manager.update_agent_status(
                self.name,
                "working",
                task.task_name,
                "thinking..."
            )

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                ]
                + user_message,
                tools=self._setup_tools(),
            )

            message = response.choices[0].message
            tool_calls = message.tool_calls

            if not tool_calls:
                task.result = message.content
                task.status = "success"
                status_manager.update_agent_status(
                    self.name,
                    "completed",
                    task.task_name,
                    "task finished"
                )
                return task

            tool_results = await self._handle_tool_calls(tool_calls)

            # Add tool results to conversation
            user_message.append(
                {"role": "assistant", "content": None, "tool_calls": tool_calls}
            )
            for tool_result in tool_results:
                user_message.append(
                    {
                        "role": "tool",
                        "content": json.dumps(tool_result["tool_result"]),
                        "tool_call_id": tool_result["tool_call_id"],
                    }
                )

    async def run(self, result_queue: asyncio.Queue):
        status_manager.update_agent_status(self.name, "idle", "", "waiting for tasks")

        while True:
            try:
                task = await self.task_queue.get()
                if task is None:
                    status_manager.remove_agent_status(self.name)
                    self.task_queue.task_done()
                    break

                self._state.assigned_tasks.append(task)
                result = await self._execute_task(task)

                status_manager.update_agent_status(
                    self.name,
                    "completed",
                    task.task_name,
                    "submitting result"
                )

                await result_queue.put(result)
                self.task_queue.task_done()

                # Brief pause to show completion status
                await asyncio.sleep(0.5)
                status_manager.update_agent_status(self.name, "idle", "", "waiting for tasks")

            except Exception as e:
                status_manager.update_agent_status(
                    self.name,
                    "failed",
                    task.task_name if 'task' in locals() else "",
                    f"error: {str(e)[:50]}"
                )
                self.task_queue.task_done()
                continue


class AgentRunner:
    def __init__(self, planner: PlanningAgent, workers: Dict[str, AgentWorker]):
        self.planner = planner
        self.workers = workers
        self.result_queue = asyncio.Queue()
        self.running = True

    async def dispatch_task(self, task: Task):
        assigned_agent = task.agent_name
        if not assigned_agent in self.workers:
            raise ValueError(f"Agent {assigned_agent} not found")
        await self.workers[assigned_agent].task_queue.put(task)

    async def execute_parallel(self, tasks: List[Task]):
        for task in tasks:
            await self.dispatch_task(task)

    async def execute_sequential(self, tasks: List[Task]):
        for task in tasks:
            await self.dispatch_task(task)
            await task._done_event.wait()

    async def handle_result_loop(self):
        while True:
            task = await self.result_queue.get()
            if task is None:
                self.result_queue.task_done()
                break
            try:
                status_manager.update_agent_status(
                    "Planner", 
                    "working", 
                    task.task_name, 
                    "reviewing task result"
                )
                
                review = await self.planner._review_single_task(task)
                
                if review.is_success == "success":
                    self.planner._state.success_tasks.append(task)
                    status_manager.update_agent_status(
                        "Planner", 
                        "completed", 
                        task.task_name, 
                        f"✓ approved - {review.feedback[:30] if review.feedback else 'passed'}"
                    )
                else:
                    task.status = "failure"
                    self.planner._state.failed_tasks.append(task)
                    status_manager.update_agent_status(
                        "Planner", 
                        "failed", 
                        task.task_name, 
                        f"✗ rejected - {review.feedback[:30] if review.feedback else 'failed'}"
                    )

                task._done_event.set()
                self.result_queue.task_done()
                
                # Brief pause to show review result
                await asyncio.sleep(1.0)
                
                # Check if there are more tasks to review
                if self.result_queue.empty():
                    status_manager.update_agent_status("Planner", "idle", "", "waiting for results")
                    
            except Exception as e:
                status_manager.update_agent_status(
                    "Planner", 
                    "failed", 
                    task.task_name if 'task' in locals() else "", 
                    f"review error: {str(e)[:30]}"
                )
                if not self.running:
                    break

    async def run(self, query: str):
        # Start the live status display
        status_manager.start_live_display()
        
        try:
            # Initialize planner status
            status_manager.update_agent_status("Planner", "idle", "", "initializing")
            
            task_list = await self.planner.plan(query)
            task_list.pretty_print()

            # Update planner status after planning
            status_manager.update_agent_status("Planner", "idle", "", "waiting for results")

            # Start worker tasks
            worker_tasks = []
            for worker in self.workers.values():
                worker_task = asyncio.create_task(worker.run(self.result_queue))
                worker_tasks.append(worker_task)

            # Start review handler
            review_handler = asyncio.create_task(self.handle_result_loop())

            # Execute tasks
            if task_list.parallel_tasks:
                await self.execute_parallel(task_list.parallel_tasks)

            if task_list.sequential_tasks:
                await self.execute_sequential(task_list.sequential_tasks)

            # Wait for all results to be processed
            await self.result_queue.join()

            await self.result_queue.put(None)

            # Signal workers to stop
            for worker in self.workers.values():
                await worker.task_queue.put(None)

            # Wait for all workers to finish
            await asyncio.gather(*worker_tasks, return_exceptions=True)

            # Stop review handler
            self.running = False
            await review_handler

            # Final status update
            status_manager.update_agent_status(
                "Planner", 
                "completed", 
                "Workflow Complete", 
                f"✓ {len(self.planner._state.success_tasks)} succeeded, ✗ {len(self.planner._state.failed_tasks)} failed"
            )
            
            # Brief pause to show final status
            await asyncio.sleep(2.0)
            
            # Generate and display final report
            await self.planner.report(task_list, query)

            return self.planner._state
            
        finally:
            # Stop the live display
            status_manager.stop_live_display()
